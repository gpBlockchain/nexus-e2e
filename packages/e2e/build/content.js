(()=>{var e={568:e=>{const s=(e=7,s=!1)=>{return Array.from({length:e},(r=s?16:36,"undefined"!=typeof crypto&&"function"==typeof crypto.getRandomValues?()=>{const e=crypto.getRandomValues(new Uint8Array(1))[0];return(e>=r?e%r:e).toString(r)}:()=>Math.floor(Math.random()*r).toString(r))).join("");var r};e.exports=s,e.exports.default=s},683:function(e,s){var r,t;"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self&&self,r=function(e){"use strict";if("object"!=typeof globalThis||"object"!=typeof chrome||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");if(void 0===globalThis.browser||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const s="The message port closed before a response was received.",r="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",t=e=>{const t={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(0===Object.keys(t).length)throw new Error("api-metadata.json has not been included in browser-polyfill");class n extends WeakMap{constructor(e,s){super(s),this.createItem=e}get(e){return this.has(e)||this.set(e,this.createItem(e)),super.get(e)}}const o=(s,r)=>(...t)=>{e.runtime.lastError?s.reject(new Error(e.runtime.lastError.message)):r.singleCallbackArg||t.length<=1&&!1!==r.singleCallbackArg?s.resolve(t[0]):s.resolve(t)},a=e=>1==e?"argument":"arguments",i=(e,s,r)=>new Proxy(s,{apply:(s,t,n)=>r.call(t,e,...n)});let g=Function.call.bind(Object.prototype.hasOwnProperty);const m=(e,s={},r={})=>{let t=Object.create(null),n={has:(s,r)=>r in e||r in t,get(n,l,c){if(l in t)return t[l];if(!(l in e))return;let A=e[l];if("function"==typeof A)if("function"==typeof s[l])A=i(e,e[l],s[l]);else if(g(r,l)){let s=((e,s)=>function(r,...t){if(t.length<s.minArgs)throw new Error(`Expected at least ${s.minArgs} ${a(s.minArgs)} for ${e}(), got ${t.length}`);if(t.length>s.maxArgs)throw new Error(`Expected at most ${s.maxArgs} ${a(s.maxArgs)} for ${e}(), got ${t.length}`);return new Promise(((n,a)=>{if(s.fallbackToNoCallback)try{r[e](...t,o({resolve:n,reject:a},s))}catch(o){console.warn(`${e} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,o),r[e](...t),s.fallbackToNoCallback=!1,s.noCallback=!0,n()}else s.noCallback?(r[e](...t),n()):r[e](...t,o({resolve:n,reject:a},s))}))})(l,r[l]);A=i(e,e[l],s)}else A=A.bind(e);else if("object"==typeof A&&null!==A&&(g(s,l)||g(r,l)))A=m(A,s[l],r[l]);else{if(!g(r,"*"))return Object.defineProperty(t,l,{configurable:!0,enumerable:!0,get:()=>e[l],set(s){e[l]=s}}),A;A=m(A,s[l],r["*"])}return t[l]=A,A},set:(s,r,n,o)=>(r in t?t[r]=n:e[r]=n,!0),defineProperty:(e,s,r)=>Reflect.defineProperty(t,s,r),deleteProperty:(e,s)=>Reflect.deleteProperty(t,s)},l=Object.create(e);return new Proxy(l,n)},l=e=>({addListener(s,r,...t){s.addListener(e.get(r),...t)},hasListener:(s,r)=>s.hasListener(e.get(r)),removeListener(s,r){s.removeListener(e.get(r))}}),c=new n((e=>"function"!=typeof e?e:function(s){const r=m(s,{},{getContent:{minArgs:0,maxArgs:0}});e(r)}));let A=!1;const d=new n((e=>"function"!=typeof e?e:function(s,t,n){let o,a,i=!1,g=new Promise((e=>{o=function(s){A||(console.warn(r,(new Error).stack),A=!0),i=!0,e(s)}}));try{a=e(s,t,o)}catch(e){a=Promise.reject(e)}const m=!0!==a&&((l=a)&&"object"==typeof l&&"function"==typeof l.then);var l;if(!0!==a&&!m&&!i)return!1;return(m?a:g).then((e=>{n(e)}),(e=>{let s;s=e&&(e instanceof Error||"string"==typeof e.message)?e.message:"An unexpected error occurred",n({__mozWebExtensionPolyfillReject__:!0,message:s})})).catch((e=>{console.error("Failed to send onMessage rejected reply",e)})),!0})),p=({reject:r,resolve:t},n)=>{e.runtime.lastError?e.runtime.lastError.message===s?t():r(new Error(e.runtime.lastError.message)):n&&n.__mozWebExtensionPolyfillReject__?r(new Error(n.message)):t(n)},u=(e,s,r,...t)=>{if(t.length<s.minArgs)throw new Error(`Expected at least ${s.minArgs} ${a(s.minArgs)} for ${e}(), got ${t.length}`);if(t.length>s.maxArgs)throw new Error(`Expected at most ${s.maxArgs} ${a(s.maxArgs)} for ${e}(), got ${t.length}`);return new Promise(((e,s)=>{const n=p.bind(null,{resolve:e,reject:s});t.push(n),r.sendMessage(...t)}))},x={devtools:{network:{onRequestFinished:l(c)}},runtime:{onMessage:l(d),onMessageExternal:l(d),sendMessage:u.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:u.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},f={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return t.privacy={network:{"*":f},services:{"*":f},websites:{"*":f}},m(e,x,t)};e.exports=t(chrome)}else e.exports=globalThis.browser},void 0===(t=r.apply(s,[e]))||(e.exports=t)}},s={};function r(t){var n=s[t];if(void 0!==n)return n.exports;var o=s[t]={exports:{}};return e[t].call(o.exports,o,o.exports,r),o.exports}(()=>{"use strict";let e=()=>({events:{},emit(e,...s){(this.events[e]||[]).forEach((e=>e(...s)))},on(e,s){return(this.events[e]=this.events[e]||[]).push(s),()=>this.events[e]=(this.events[e]||[]).filter((e=>e!==s))}});var s=r(683);class t extends Error{name="NonError";constructor(e){super(t._prepareSuperMessage(e))}static _prepareSuperMessage(e){try{return JSON.stringify(e)}catch{return String(e)}}}const n=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0}],o=Symbol(".toJSON was called"),a=({from:e,seen:s,to_:r,forceEnumerable:t,maxDepth:i,depth:g})=>{const m=r||(Array.isArray(e)?[]:{});if(s.push(e),g>=i)return m;if("function"==typeof e.toJSON&&!0!==e[o])return(e=>{e[o]=!0;const s=e.toJSON();return delete e[o],s})(e);for(const[r,n]of Object.entries(e))"function"==typeof Buffer&&Buffer.isBuffer(n)?m[r]="[object Buffer]":null===n||"object"!=typeof n||"function"!=typeof n.pipe?"function"!=typeof n&&(n&&"object"==typeof n?s.includes(e[r])?m[r]="[Circular]":(g++,m[r]=a({from:e[r],seen:[...s],forceEnumerable:t,maxDepth:i,depth:g})):m[r]=n):m[r]="[object Stream]";for(const{property:s,enumerable:r}of n)"string"==typeof e[s]&&Object.defineProperty(m,s,{value:e[s],enumerable:!!t||r,configurable:!0,writable:!0});return m};var i,g=r(568),m=/^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/,l=e=>{const[,s,r,t]=e.match(m)||[];return{context:s,tabId:+r,frameId:t?+t:void 0}},c=e=>s[e],A=c("devtools")?"devtools":c("tabs")?(()=>{var e,r,t;const n=s.runtime.getManifest();if("undefined"==typeof window)return"background";const o=(null==(e=n.browser_action)?void 0:e.default_popup)||(null==(r=n.action)?void 0:r.default_popup);return o&&new URL(s.runtime.getURL(o)).pathname===window.location.pathname?"popup":(null==(t=n.options_ui)?void 0:t.page)&&new URL(s.runtime.getURL(n.options_ui.page)).pathname===window.location.pathname?"options":"background"})():c("extension")?"content-script":"undefined"!=typeof document?"window":null,d=g(),p=new Map,u=new Map,x=new Set,f=new Map,b=null;function h(e){const{origin:s,destination:r}=e;if(!e.hops.includes(d)&&(e.hops.push(d),"content-script"!==A||![r,s].some((e=>"window"===(null==e?void 0:e.context))))){if(!r)return async function(e){const{transactionId:s,messageID:r,messageType:t}=e;switch(t){case"reply":return(()=>{const r=p.get(s);if(r){const{err:t,data:n}=e;if(t){const e=t,s=self[e.name],n=new("function"==typeof s?s:Error)(e.message);for(const s in e)n[s]=e[s];r.reject(n)}else r.resolve(n);p.delete(s)}})();case"message":return(async()=>{let s,t,n=!1;try{const o=u.get(r);if("function"!=typeof o)throw n=!0,new Error(`[webext-bridge] No handler registered in '${A}' to accept messages with id '${r}'`);s=await o({sender:e.origin,id:r,data:e.data,timestamp:e.timestamp})}catch(e){t=e}finally{if(t&&(e.err=function(e,s={}){const{maxDepth:r=Number.POSITIVE_INFINITY}=s;return"object"==typeof e&&null!==e?a({from:e,seen:[],forceEnumerable:!0,maxDepth:r,depth:0}):"function"==typeof e?`[Function: ${e.name||"anonymous"}]`:e}(t)),h({...e,messageType:"reply",data:s,origin:{context:A,tabId:null},destination:e.origin,hops:[]}),t&&!n)throw s}})()}}(e);if(r.context){if("window"===A)return y(window,e);if("content-script"===A&&"window"===r.context)return e.destination=null,y(window,e);if(["devtools","content-script","popup","options"].includes(A))return"background"===r.context&&(e.destination=null),b.postMessage(e);if("background"===A){const{context:t,tabId:n,frameId:o}=r,{tabId:a}=s;"window"!==t?e.destination=null:e.destination.tabId=null;let i=["popup","options"].includes(t)?t:`${"window"===t?"content-script":t}@${n||a}`;o&&(i=`${i}.${o}`);const g=f.get(i);g?g.postMessage(e):x.add({resolvedDestination:i,message:e})}}}}async function w({data:e,ports:s}){if("content-script"!==A)if("__crx_bridge_verify_listening"===e.cmd&&e.scope===i&&e.context!==A)s[0].postMessage(!0);else if("__crx_bridge_route_message"===e.cmd&&e.scope===i&&e.context!==A){const{payload:s}=e;"content-script"===A&&(s.origin={context:"window",tabId:null}),h(s)}}function y(e,s){!function(){throw new Error("webext-bridge uses window.postMessage to talk with other \"window\"(s), for message routing and stuff,which is global/conflicting operation in case there are other scripts using webext-bridge. Call Bridge#setNamespace(nsps) to isolate your app. Example: setNamespace('com.facebook.react-devtools'). Make sure to use same namespace across all your scripts whereever window.postMessage is likely to be used`")}();const r=new MessageChannel,t=setTimeout((()=>{r.port1.onmessage=null,y(e,s)}),300);r.port1.onmessage=()=>{clearTimeout(t),e.postMessage({cmd:"__crx_bridge_route_message",scope:i,context:A,payload:s},"*")},e.postMessage({cmd:"__crx_bridge_verify_listening",scope:i,context:A},"*",[r.port2])}function v(e,s){u.set(e,s)}async function k(e,s,r="background"){const t="string"==typeof r?l(r):r,n="Bridge#sendMessage ->";if(!t.context)throw new TypeError(`${n} Destination must be any one of known destinations`);if("background"===A){const{context:e,tabId:s}=t;if("background"!==e&&!s)throw new TypeError(`${n} When sending messages from background page, use @tabId syntax to target specific tab`)}return new Promise(((r,n)=>{const o={messageID:e,data:s,destination:t,messageType:"message",transactionId:g(),origin:{context:A,tabId:null},hops:[],timestamp:Date.now()};p.set(o.transactionId,{resolve:r,reject:n}),h(o)}))}!function e(){if(null===A)throw new Error("Unable to detect runtime context i.e webext-bridge can't figure out what to do");if("window"!==A&&"content-script"!==A||window.addEventListener("message",w),"content-script"===A&&top===window&&((b=s.runtime.connect()).onMessage.addListener((e=>{h(e)})),b.onDisconnect.addListener((()=>{b=null,e()}))),"content-script"===A&&top!==window&&((b=s.runtime.connect()).onMessage.addListener((e=>{h(e)})),b.onDisconnect.addListener((()=>{b=null,e()}))),"devtools"===A){const{tabId:r}=s.devtools.inspectedWindow,t=`devtools@${r}`;(b=s.runtime.connect(void 0,{name:t})).onMessage.addListener((e=>{h(e)})),b.onDisconnect.addListener((()=>{b=null,e()}))}if("popup"===A||"options"===A){const r=`${A}`;(b=s.runtime.connect(void 0,{name:r})).onMessage.addListener((e=>{h(e)})),b.onDisconnect.addListener((()=>{b=null,e()}))}"background"===A&&s.runtime.onConnect.addListener((e=>{let s=e.name||`content-script@${e.sender.tab.id}`;const r=e.sender.frameId;r&&(s=`${s}.${r}`);const{context:t,tabId:n,frameId:o}=l(s);(n||"popup"===t||"options"===t)&&(f.set(s,e),x.forEach((r=>{r.resolvedDestination===s&&(e.postMessage(r.message),x.delete(r))})),e.onDisconnect.addListener((()=>{f.delete(s)})),e.onMessage.addListener((e=>{var s;(null==(s=null==e?void 0:e.origin)?void 0:s.context)&&(e.origin.tabId=n,e.origin.frameId=o,h(e))})))}))}();var _=class{constructor(s){this.handleStreamClose=()=>{this.isClosed||(this.isClosed=!0,this.emitter.emit("closed",!0),this.emitter.events={})},this.internalInfo=s,this.emitter=e(),this.isClosed=!1,_.initDone||(v("__crx_bridge_stream_transfer__",(e=>{const{streamId:s,streamTransfer:r,action:t}=e.data,n=_.openStreams.get(s);n&&!n.isClosed&&("transfer"===t&&n.emitter.emit("message",r),"close"===t&&(_.openStreams.delete(s),n.handleStreamClose()))})),_.initDone=!0),_.openStreams.set(s.streamId,this)}get info(){return this.internalInfo}send(e){if(this.isClosed)throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");k("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:e,action:"transfer"},this.internalInfo.endpoint)}close(e){e&&this.send(e),this.handleStreamClose(),k("__crx_bridge_stream_transfer__",{streamId:this.internalInfo.streamId,streamTransfer:null,action:"close"},this.internalInfo.endpoint)}onMessage(e){return this.getDisposable("message",e)}onClose(e){return this.getDisposable("closed",e)}getDisposable(e,s){const r=this.emitter.on(e,s);return Object.assign(r,{dispose:r,close:r})}},I=_;I.initDone=!1,I.openStreams=new Map;var C,E,M=new Map,T=e();v("__crx_bridge_stream_open__",(e=>new Promise((s=>{const{sender:r,data:t}=e,{channel:n}=t;let o=!1,a=()=>{};const i=()=>{const e=M.get(n);"function"==typeof e?(e(new I({...t,endpoint:r})),o&&a(),s(!0)):o||(o=!0,a=T.on("did-change-stream-callbacks",i))};i()})))),window.addEventListener("message",(function(e){"NEXUS_INPAGE"===e.data.target&&k("notification",{},"background")})),"html"===(null===(C=document.doctype)||void 0===C?void 0:C.name)&&((E=document.createElement("script")).async=!1,E.src=chrome.runtime.getURL("inpage.js"),E.onload=function(){return E.remove()},(document.head||document.documentElement).appendChild(E))})()})();
//# sourceMappingURL=content.js.map